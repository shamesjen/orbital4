// Code generated by hertz generator.

package api

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"

	api "hello/biz/model/api"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/cloudwego/kitex/client"
	"github.com/cloudwego/kitex/client/genericclient"
	"github.com/cloudwego/kitex/pkg/generic"
)

// Call .
// @router /post [POST]
func Call(ctx context.Context, c *app.RequestContext) {
	//url to sendreq?
	var requestURL string = "http://example.com/life/client/11?vint64=1&items=item0,item1,item2"
	var IDLPATH string = "idl/hello.thrift"
	var jsonData map[string]interface{}

	//return data in bytes
	response := c.GetRawData()

	err := json.Unmarshal(response, &jsonData)

	if err != nil {
		fmt.Println("Error", err)
		c.String(consts.StatusBadRequest, "bad post request")
		return
	}

	//wtv key value ned be consistet
	dataValue, ok := jsonData["message"].(string)
	if !ok {
		c.String(consts.StatusBadRequest, "data provided not a string")
		return
	}
	
	jsonData["message"] = dataValue
	fmt.Println(jsonData)
	fmt.Println("message is " + dataValue)

	if !ok {
		c.String(consts.StatusBadRequest, "data provided not a string")
		return
	}

	//working until here

	responseFromRPC, err := makeThriftCall(IDLPATH, jsonData, requestURL, ctx, dataValue)


	if err != nil {
		fmt.Println(err)
		c.String(consts.StatusBadRequest, "error in thrift call ")
		return
	}

	fmt.Println("Post request successful")

	// strResponse, ok := responseFromRPC.(string)
	// if !ok {
	// fmt.Println("responseFromRPC is not a string")
	// return
	// }
	
	c.JSON(consts.StatusOK, responseFromRPC)
}

func makeThriftCall(IDLPath string, jsonData map[string]interface{}, requestURL string, ctx context.Context, dataValue string) (interface{}, error) {
	p, err := generic.NewThriftFileProvider(IDLPath)
	if err != nil {
		fmt.Println("error creating thrift file provider")
		return 0, err
	}
	fmt.Println(dataValue)
	g, err := generic.JSONThriftGeneric(p)
	if err != nil {
		return 0, errors.New(("error creating thrift generic"))
	}

	cli, err := genericclient.NewClient("Call", g, client.WithHostPorts("0.0.0.0:8888"))

	if err != nil {
		return 0, errors.New(("invalid client name"))
	}

	// req, err := http.NewRequest(http.MethodGet, requestURL, bytes.NewBuffer(response))
	// req.Header.Set("token", "1")
	// if err != nil {
	// 	fmt.Println("error construting req")
	// 	return 0, err
	// }
	// Remove this part:
	// err1 := json.Unmarshal(response, &jsonData)

	// Directly marshal jsonData into a string for the RPC call:

	req := api.NewRequest()
	req.Message = dataValue
	fmt.Println(jsonData)
	jsonString, _ := json.Marshal(jsonData)
	

	// customReq, err := generic.FromHTTPRequest(req)

	// if err != nil {
	// 	fmt.Println("error constructing xcustom req")
	// 	return 0, err
	// }

	// fmt.Println(customReq)

	resp, err := cli.GenericCall(ctx, "call", string(jsonString))

	fmt.Println("generic call successful")
	fmt.Println(resp)

	if err != nil {
		fmt.Println("error making generic call")
		return 0, err
	}


	respString, ok := resp.(string)
	if !ok {
		fmt.Println("resp is not a string. Actual value:", resp)
		return nil, errors.New("resp is not a string")
	}

	fmt.Println("generic call successful:", respString)

	var respData map[string]interface{}
	err = json.Unmarshal([]byte(respString), &respData)
	if err != nil {
		fmt.Println("error unmarshalling response", err)
		return nil, err
	}

	fmt.Println("Received message:", respData["Msg"])
	fmt.Println("Additional data:", respData["AdditionalData"])

	return respData, nil

}
	// resp should be a JSON string. Unmarshal it into a map.
// 	var respData map[string]interface{}
// 	err = json.Unmarshal([]byte(resp.(string)), &respData)
// 	if err != nil {
// 		fmt.Println("oh no")
// 	}

// 	fmt.Println("Received message:", respData["Msg"])
// 	fmt.Println("Additional data:", respData["AdditionalData"])

// 	return respData, nil
// }

	// respString := resp.(string)
	// var respData map[string]interface{}
	// err = json.Unmarshal([]byte(respString), &respData)
	// if err != nil {
	// 	fmt.Println("error unmarshalling response", err)
	// 	return 0, err
	// }
	// respMap, ok := resp.(map[string]interface{})
	// if !ok {
	// 	// handle error, resp is not a map
	// }

	// fmt.Println("Received message:", respMap["Msg"])
	// fmt.Println("Additional data:", respMap["AdditionalData"])

// 	fmt.Println("Received message:", respData["Msg"])
// 	fmt.Println("Additional data:", respData["AdditionalData"])

// 	return resp, nil
// }


